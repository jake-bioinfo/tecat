---
title: "TLD Example Vignette ONT"
author: "Jake Reed"
date: '`r Sys.Date()`'
output:
  html_document: 
    theme: simplex
    highlight: tango
    toc: yes
  pdf_document:
    highlight: tango
    toc: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
        echo = TRUE,
        collapse = TRUE,
        comment = "#>"
)
```

# 1. Installation

# 2. Showcase

## Import Functions
```{r source}
source("00-paths.R")
source(file.path(paths$bin, "fG-helper_functions.R"))
library(Biostrings)

# Create directories
for (dir in paths) dir.create(file.path(dir), 
                              showWarnings = FALSE)

# Sample name
sample_name <- "HG002_ONT"

# Create results directory
dir.create(file.path(paths$example_results, sample_name), 
           showWarnings = FALSE)

sample_file <- file.path(paths$example_data, 
                         "data/SRR24462105/SRR24462105.fastq")
data_dir <- file.path(paths$example_data, "data", 
                      "SRR24462105")

# Set width
options(width = 300)
```

## Process Fastq
This process is used in order to split files in order to support efficient parallelization. 
Ideally, you would set `target_ram_size_gb` * `threads` to be equal to something near the 
total RAM for your machine. The fastq file can be downloaded from the SRA database using
SRA toolkit. Here are the commands you would use to download the fastq file for this
experiment. 

<!-- ```{bash}
# Download SRA toolkit
wget https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/3.0.7/sratoolkit.3.0.7-ubuntu64.tar.gz
tar -xzf sratoolkit.3.0.7-ubuntu64.tar.gz
cd sratoolkit.3.0.7-ubuntu64/bin
data_dir=r file.path(paths$example_data, "data")
echo $data_dir

# Download fastq file
./prefetch --progress --resume yes --output-directory $data_dir SRR11008518

# Convert to fastq
./fastq-dump --split-3 -A $data_dir/SRR11008518/SRR11008518.sra -outdir $data_dir/split
``` -->

```{r Split_Fastq, eval = FALSE}
source(file.path(paths$bin, "f01-Fastq_Processing.R"))

# Split large fastq file into files that will occupy
# 2GB of RAM in order to take advantage of all processors
# (20) with given RAM (62GB).
if(!file.exists(list.files(file.path(dirname(sample_file), "split"), 
                           full.names = TRUE)[1])) {
   stats_fl <- auto_split(in_fastq = sample_file,
                          prefix = "HG002_ONT", 
                          threads = 18, 
                          extension = ".gz", 
                          target_ram_size_gb = 2)
                          
  # Save stats
  saveRDS(stats_fl, file.path(paths$example_results,
                                sample_name, 
                                "stats_fl.rds"))
}

# Test cmd for ONT
split_fastq(in_fastq = sample_file, 
            size = "50000", 
            prefix = "HG002_ONT", 
            threads = 18, 
            out_dir = paste0(data_dir, "/split"), 
            extension = ".gz")
```

## Process Reference Fastq
```{r process_reference, eval = FALSE}
## Switching denovo motif analysis to streme from meme suite, need 
## to add to dependencies
source(file.path(paths$bin, "f02-Reference_Processing.R"))
options(meme_bin = "~/meme/bin")
reference_file <- file.path(paths$example_data, "ref/chm13v2.0.fa.gz")
reference <- readDNAStringSet(reference_file, format = "fasta")

# Process reference file 
# # PB Settings
# motif_analysis <- telomere_motif(data_ref = reference,
#                                  reference_telo_length = 2000,
#                                  telo_motif_length = 6, 
#                                  number_of_motifs = 10,
#                                  number_of_repeats = 9, 
#                                  platform = "PB",
#                                  threads = 18)

# ONT Settings
motif_analysis <- telomere_motif(data_ref = reference,
                                 reference_telo_length = 2000,
                                 telo_motif_length = 6, 
                                 number_of_motifs = 10,
                                 number_of_repeats = 15, 
                                 platform = "ONT",
                                 threads = 18)

print(paste("Number of motifs found: ", length(motif_analysis$motifs)))
cat("\n")
print(paste("Grep pattern for pattern matching and initial search: ", 
            motif_analysis$grep_list))
## Here it appears with new method we can use 6 X motif for ONT, maybe 9 X motif for PB???
## Maybe it doesn't matter. 

# Save results
saveRDS(motif_analysis, file.path(paths$example_results,
        sample_name, "motif_analysis_results.rds"))

# Clean up
rm(list = c("reference_file", "reference"))
gc()
```

## Isolate telomere reads
```{r telo_search, eval = FALSE}
motif_analysis <- readRDS(file.path(paths$example_results,
                                    sample_name,
                                    "motif_analysis_results.rds"))
                                    
# Source functions for pattern searching
source(file.path(paths$bin, "f03-Pattern_searching.R"))

# Run pattern searh on all split fastq files
file_list <- list.files(file.path(data_dir, "split"), 
                        full.names = TRUE)

# For testing
file_list <- file_list[1:100]

# Create output directory
out <- file.path(data_dir, "telo")
dir.create(out, showWarnings = FALSE)

# Search telomeres 
## Need to explain in documentation that threads should match number of files
telomere_stats <- telo_search(fastq_files = file_list,
                              grep_list = motif_analysis$grep_list,
                              threads = 16,
                              out_dir = out, 
                              progress = TRUE)
knitr::kable(head(telomere_stats))

# Clean up
rm(list = c("file_list", "out"))
gc()

# Save telomere_stats
saveRDS(telomere_stats, file.path(paths$example_results,
                                  sample_name,
                                  "telomere_stats.rds"))
```

## Cut telomere reads into sliding windows
```{r telo_cut, eval = FALSE}
telomere_stats <- readRDS(file.path(paths$example_results,
                                    sample_name,
                                    "telomere_stats.rds"))

# Source functions for cutting telomere reads into sliding windows
source(file.path(paths$bin, "f04-Sliding_window.R"))
dir.create(file.path(paths$example_results, sample_name,
                     "windows"), 
           showWarnings = FALSE)
window_out <- file.path(paths$example_results, sample_name, "windows")

# Temporary file list
out <- file.path(data_dir, "telo")

# Generate sliding windows
window_files <- sliding(telomere_files = telomere_stats$file_list, 
        window_length = 200, 
        environment = "linux",
        threads = 18,
        return_windows = FALSE,
        save_files = TRUE,
        out_dir = window_out,
        progress = TRUE, 
        compress = TRUE, 
        verbose = TRUE, 
        process_file_number = 4)

# Satus
print(paste0("\nFinished processing all files and saving results to", window_out, "\n"))
```

## Calculate frequency of telomere motifs in sliding windows
```{r telo_freq, eval = FALSE}
# Source functions for calculating telomere motif frequencies
source(file.path(paths$bin, "f05-Generate_telomere_frequencies.R"))

# Load in data 
motif_analysis <- readRDS(file.path(paths$example_results, 
                                    sample_name, 
                                    "motif_analysis_results.rds"))

# Directories
win_dir <- file.path(paths$example_results, 
        "HG002_ONT", 
        "windows")

# For loop over all telomere windows files
wins <- list.files(win_dir, full.names = TRUE)

dir.create(file.path(paths$example_results, 
                     sample_name, "frequencies"), 
           showWarnings = FALSE)

out_dir = file.path(paths$example_results, 
                    sample_name, 
                    "frequencies")
# Test
freqs <- frequencies(windows_files = wins, 
                     motifs = motif_analysis$motifs, 
                     environment = "linux", 
                     parallel = TRUE, 
                     threads = 18, 
                     save_files = TRUE,
                     out_dir = out_dir,
                     process_file_number = 0, 
                     verbose = FALSE)

# Save Frequencies
saveRDS(freqs, file.path(paths$example_results,
                         sample_name, 
                         "freqs.rds"))
cat("\nNumber of telomeres found: ", length(freqs), "\n")
cat("\nExample telomere frequencies:\n")
knitr::kable(head(freqs[[1]]))
cat("\n...")
knitr::kable(tail(freqs[[1]]))

# Clean up
rm(list = setdiff(ls(), c("freqs", 
                          "paths", "sample_name")))
gc()

# Save frequencies
saveRDS(freqs, file.path(paths$example_results,
                                        sample_name,
                                        "motif_frequencies.rds"))
```

# Determine telomere length
## !-- Somewhere I need to add telomere name designation in this 
## analysis --!
```{r telomere_length, eval = TRUE}
# Load data
telomere_frequencies <- readRDS(file.path(paths$example_results,
                                          sample_name,
                                          "motif_frequencies.rds"))

# Source functions for determining telomere length
source(file.path(paths$bin, "f06-Telomere_length.R"))

# Threshold determination
thresh_df <- determine_threshold(telomere_list = telomere_frequencies,
                                 threads = 18, 
                                 sample_ratio = 0.025)

# Save threshold data
saveRDS(thresh_df, file.path(paths$example_results,
                             sample_name, 
                             "threshold_data.rds"))
```

# Explore data
## Inspect threshold data
Need to look into why telomere lengths aren't being calculated for some reads.
```{r inspect_threshold_data, eval = TRUE}
# Load data
telomere_frequencies <- readRDS(file.path(paths$example_results,
                                          sample_name,
                                          "motif_frequencies.rds"))
thresh_df <- readRDS(file.path(paths$example_results,
                               sample_name,
                               "threshold_data.rds"))

# Number of submitted telomeres
print(paste0("Number of submitted telomeres: ", length(telomere_frequencies), 
        "\n"))

# Debugging
na_indices <- which(is.na(thresh_df$start[[50]]$telomere_end))
misfits <- telomere_frequencies[na_indices]
# Test all indices are NA
print(paste0("Number of NA (misassigned) telomeres: ", length(misfits), 
        "\n"))

# Fraction misassigned at best threshold
print(paste0("Fraction misassigned at 50-50 threshold: ",
        length(misfits) / length(telomere_frequencies), "\n"))

# Look into first read problem
ref_lens <- thresh_df$start[[50]]
head(ref_lens, 50)

# Look at average length in telomeres
telomere_lengths <- ref_lens$telomere_length[!is.na(ref_lens$telomere_end)]
print(paste0("Mean telomere length at 50-50 without NA: ", mean(telomere_lengths), 
        "\n"))

# Create histogrma of telomere lengths
hist(telomere_lengths, breaks = sqrt(length(telomere_lengths)), 
     main = "Histogram of Telomere Lengths", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")

# Less than 2k length
ind_2k <- which(telomere_lengths < 2000 & 
                !is.na(telomere_lengths) &
                telomere_lengths > 0)
print(paste0("Number of telomeres less than 2kbp: ", length(ind_2k), "\n"))
less_2k <- telomere_lengths[ind_2k]
print(paste0("Mean of telomere lengths at 50-50 which were less than 2 kbp: ", 
        mean(less_2k), "\n"))
hist(less_2k, breaks = sqrt(length(less_2k)), 
     main = "Histogram of Telomere Lengths < 2kbp", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")

minus_2k <- telomere_lengths[which(telomere_lengths > 2000)]
print(paste0("Mean of telomere lengths at 50-50 which were greater than 2 kbp: ", 
        mean(minus_2k), "\n"))
hist(minus_2k, breaks = sqrt(length(minus_2k)), 
     main = "Histogram of Telomere Lengths > 2kbp", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")
```

## Delve into threshold data, format
This section is going to be focused on constructing a dataset which 
can be looked at more closely. Basically we need a dataset based on 
starting threshold which shows sensitivity while the ending threshold
shows telomere length.
```{r formatting, eval = TRUE}
# Start sensitivity
start_number_of_telos <- unlist(lapply(thresh_df$start, function(x) {
  length(which(!is.na(x$telomere_end)))}))
sensitivity_df <- data.frame(start = seq(1, 100, 1), 
                             end = rep(5, 100), 
                             number_of_telos = start_number_of_telos)

# Telomere length
# End telomere length
telomere_lengths_end <- lapply(thresh_df$end, function(x) {
  vals <- x$telomere_length[!is.na(x$telomere_end)]
  x <- mean(vals)
  if(x != 0 & length(vals) > 1) {
    std_dev <- sd(vals)
  } else {
    std_dev <- 0
  }
  ret_frame <- data.frame(mean = x,
                          std_dev = std_dev)
  return(ret_frame)
})
end_df <- do.call(rbind, telomere_lengths_end)
telomere_length_df <- cbind(start = rep(20, 100), 
                            end = seq(1, 100, 1), 
                            end_df)

# Print data
print(paste0("\nStart sensitivity data:"))
knitr::kable(head(sensitivity_df))
print(paste0("\n..."))
knitr::kable(tail(sensitivity_df))
print(paste0("\n"))

print(paste0("\nTelomere length data:"))
knitr::kable(head(telomere_length_df))
print(paste0("\n..."))
knitr::kable(tail(telomere_length_df))
```

## Plot threshold data
```{r plot_threshold_data, eval = TRUE}
library(ggplot2)
library(cowplot)

# Plot sensitivity and telomere line graphs next to each other
sens_plot <- ggplot(sensitivity_df, aes(x = start, y = number_of_telos)) +
  geom_line() +
  geom_point() +
  labs(x = "Start Threshold", 
       y = "Number of Telomeres", 
       title = "Telomere Sensitivity") +
  theme_bw()

telomere_plot <- ggplot(telomere_length_df, aes(x = end, y = mean)) +
  geom_line() +
  geom_point() +
  labs(x = "End Threshold", 
       y = "Telomere Length", 
       title = "Telomere Length") +
  theme_bw()

plot_grid(sens_plot, telomere_plot, ncol = 2)

# Print best thresholds
best_start <- sensitivity_df$start[which.max(sensitivity_df$number_of_telos)]
print(paste0("\nBest start threshold: ", best_start, "\n"))
best_end <- telomere_length_df$end[which.max(telomere_length_df$mean)]
print(paste0("\nBest end threshold: ", best_end, "\n"))
```

## Determine optimal thresholds
For now run all telomeres with start threshold of
25 and end threshold of 10.
```{r check_lengths, eval = TRUE}
source(file.path(paths$bin, "f06-Telomere_length.R"))

# Load data
telomere_frequencies <- readRDS(file.path(paths$example_results,
                                          sample_name,
                                          "motif_frequencies.rds"))

# Run findtellength over all telomeres in parallel
library(parallel)
# Setup parallel environment
cl <- parallel::makeCluster(18)
parallel::clusterExport(cl, c("findTelLength"), 
                        envir = environment())
invisible(parallel::clusterEvalQ(cl, require(plyr)))

results <- invisible(parallel::parLapply(cl, telomere_frequencies, 
                                         findTelLength, st.thresh = 20, 
                                         en.thresh = 15))
parallel::stopCluster(cl)

results_df <- do.call(rbind.data.frame, results)

head(results_df)

# Save results
saveRDS(results_df, file.path(paths$example_results,
                              sample_name, 
                              "results_df.rds"))

## This is very interesting
# saveRDS(results_df, file.path(paths$example_results,
#                               sample_name, 
#                               "results_df_interesting.rds"))

# Look at average length in telomeres
telomere_lengths <- results_df$telomere_length[which(!is.na(results_df$telomere_end) & 
                                               results_df$telomere_length > 0)]

# Print fraction na
print(paste0("Fraction NA: ", sum(is.na(results_df$telomere_end)) / nrow(results_df)))

# Telomere update print(paste0)
print(paste0("Number of telomeres found: ", length(telomere_lengths), "\n"))
wo_na <- results_df[!is.na(results_df$telomere_end), ]
print(paste0("Mean telomere length at 20-15 without NA: ", mean(wo_na$telomere_length)))

# Create histogrma of telomere lengths
hist(telomere_lengths, breaks = sqrt(length(telomere_lengths)), 
     main = "Histogram of Telomere Lengths", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")
```

```{r less2k, eval = FALSE}
# Less than 2k length print(paste0s )
total_tel <- length(results_df$telomere_length)
num_less_2k <- sum(results_df$telomere_length < 2000 & 
                   !is.na(results_df$telomere_end))
print(paste0("Total number of telomeres: ", total_tel)) 
print(paste("Number of telomeres less than 2kbp: ", 
        num_less_2k))

print(paste0("Results table follows:"))
knitr::kable(head(results_df, 20))

# Assign NAs 
ind_n_a <- which(is.na(results_df$telomere_end))
n_a <- results_df[ind_n_a, ]  
print(paste0("\nNumber of NAs: ", length(ind_n_a)))
print(paste0("\nNA results table follows:"))
knitr::kable(head(n_a, 20))

# Assign < 2k
ind_2k <- which(results_df$telomere_length < 2000 & 
                !is.na(results_df$telomere_end))
less_2k <- results_df[ind_2k, ]

print(paste0("\nNumber of telomeres less than 2kbp: ", length(ind_2k)))
print(paste0("\nResults table follows:"))
knitr::kable(head(less_2k, 20))
```

## Investigate NAs
```{r investigate_nas, eval = FALSE}
ls()
tail(telomere_frequencies[[ind_n_a[1]]], 50)
print(paste0("Incorrect assignment, this is a telomere\n"))
tail(telomere_frequencies[[ind_n_a[2]]], 50)
print(paste0("Incorrect assignment, this is a telomere\n"))
head(telomere_frequencies[[ind_n_a[3]]], 50)
tail(telomere_frequencies[[ind_n_a[3]]], 50) ## Need to check this one
print(paste0("Correct assignment, this is not a telomere\n"))

# Inspect a random NA
ind <- sample(ind_n_a, 1)
telomere_frequencies[[ind]]
print(paste0("Check and see what you find?"))
print(paste0("This is correctly assigned NA\n"))

# The problem ==> given the low start threshold, the telomere is being
# assigned NA bc both ends are being assigned or above the threshold.
# --> this problem definitely needs to be addressed and corrected, 
# for now rerun with with a threshold of 50 and see what happens.
```

## Investigate NA
```{r investigate_na, eval = FALSE}
# For loop over all telomere windows files
telo_windows <- list.files(file.path(paths$example_results, 
                           sample_name, "windows"), 
                           pattern = "sliding_windows", 
                           full.names = TRUE)
windows <- unlist(readRDS(telo_windows[1]))
print(paste0("Number of telomeres: ", length(windows), 
        ", in first file"))

# Match third NA telomere with appropriate window
freq_nm <- names(telomere_frequencies)[ind_n_a[1]]
win <- try(windows[[which(names(windows) == freq_nm)]], 
           silent = TRUE)
# Doesn't exist, need to load up later files
print(paste0("Need to load up later file which contains telomere: ", 
        freq_nm))
#print(paste0("List of telomere window files:", )
#        paste0("\n", telo_windows, collapse = "\n"))

# Check last
windows <- unlist(readRDS(telo_windows[length(telo_windows)]))
which(names(windows) == freq_nm)
names(windows)[[1]]

# Time to check all files
check <- FALSE
while(!check) {
    for (i in 1:length(telo_windows)) {
        windows <- unlist(readRDS(telo_windows[i]))
        if (length(which(names(windows) == freq_nm)) > 0) {
            print(paste0("Found telomere in file: ", telo_windows[i]))
            check <- TRUE
            # Assign window
            win <- windows[[which(names(windows) == freq_nm)]]
            file <- telo_windows[i]
            break
        }
    }
}

# For future reference, file which includes "HG002_ONT093_telomere_3"
file <- "../../shared_data/hs/results/tld_dev_results/HG002_ONT/windows/sliding_windows_1.rds"
print(paste0("File which includes telomere: ", file))
fl <- file

# Check out window
windows <- unlist(readRDS(fl))
win <- windows[[which(names(windows) == freq_nm)]]
print(paste0("\nWindow for telomere: ", freq_nm, " follows."))
knitr::kable(tail(win, 20))
knitr::kable(head(win, 20))

print(paste0("\nEnd of frequency list for telomere: ", freq_nm, " follows."))
knitr::kable(tail(telomere_frequencies[[ind_n_a[1]]], 30))
```

## Investigate < 2k
```{r investigate_2k, eval = FALSE}
# For loop over all telomere windows files
telo_windows <- list.files(file.path(paths$example_results, 
                           sample_name, "windows"), 
                           pattern = "telo_windows", 
                           full.names = TRUE)
windows <- unlist(readRDS(telo_windows[1]))
print(paste0("Number of telomeres: ", length(windows), 
        ", in first file"))

# Load up some 2kpb telomeres
ls()
head(ind_2k)
length(ind_2k)
freq_2k <- telomere_frequencies[ind_2k]
res_2k <- results_df[ind_2k, ]
head(res_2k)
names_2k <- rownames(res_2k) 
head(names_2k)

ratio <- length(which(results_df[ind_2k, "telomere_end"] == "R")) / nrow(results_df[ind_2k, ])
print(paste0("Ratio of R to L telomeres: ", ratio, " before correction."))

# Check out windows
windows[[1]]
names(windows)
win_2k <- windows[which(names(windows) %in% names_2k)]
head(res_2k)
head(ind_2k)
telomere_frequencies[[ind_2k[1]]]
test_tel <- names(telomere_frequencies)[ind_2k[1]]
print(paste0("\nWill be using telomere, ", test_tel, " for testing \n
        new telomere length algorithm."))
tail(win_2k[[1]], 20)
win_2k[[1]][85:96]
print(paste0("Incorrect assignment. \n"))

# Further check of "L" telomeres
L_2k.ind <- which(results_df[ind_2k, "telomere_end"] == "L")
## Need to inspect the sequences (windows) for all the "L" telomere ends
for (i in L_2k.ind) {
        df <- telomere_frequencies[[ind_2k[i]]]
        print(paste0("\nThis is L_2k.ind: ", i, " df\n"))
        print(head(df, 20))
}

# Here is a candidate telomere: 
candidates <- c("HG002_ONT051_telomere_1", "HG002_ONT086_telomere_2",
                "HG002_ONT087_telomere_1", "HG002_ONT013_telomere_1")
freqs <- telomere_frequencies[candidates]
lapply(freqs, head, 50)
length_est <- c(5600, 4000, 
                7400, 3600)
end_win <- c(29, 20, 37, 18)
```

## Further look into "L" 2kbp telomeres
```{r further_2k, eval = FALSE}
# Collect candidate windows
candidates
# candidate_windows <- list()
# for (i in 1:length(telo_windows)) {
#         windows <- unlist(readRDS(telo_windows[i]))
#         print(paste0("\nChecking file: ", telo_windows[i]))
#         for (j in 1:length(candidates)) {
#                 if (length(which(names(windows) == candidates[j])) > 0) {
#                         print(paste0("\n\t\tFound candidate: ", candidates[j], )
#                                 "\t in file: ", telo_windows[i])
#                         print(paste0("\tIndex: ", j, " in candidates"))
#                         print(paste0("\tIndex: ", i, " in telo_windows"))
#                         can_win <- windows[[which(names(windows) == candidates[j])]]
#                         candidate_windows <- c(candidate_windows, can_win)
#                 }
#         }
# }

# Save candidate windows
# saveRDS(candidate_windows, file.path(paths$example_results,
#                                      sample_name, 
#                                     "candidate_windows_L_short_telomeres.rds"))

# Load candidate windows
candidate_windows <- readRDS(file.path(paths$example_results,
                                       sample_name, 
                                       "candidate_windows_L_short_telomeres.rds"))

head(candidate_windows[[1]])
for (i in 1:length(candidate_windows)) {
        print(paste0("\nViewing telomere window: ", unique(names(candidate_windows[[i]]))))
        seq <- as.data.frame(candidate_windows[[i]][1:end_win[i]])[, "seq"]
        print(knitr::kable(seq))
}
```

## Further look into "L" 2kbp telomeres, check windows
```{r further_2k_2, eval = FALSE}
l <- results_df[which(results_df$telomere_end == "L"), ]
r <- results_df[which(results_df$telomere_end == "R"), ]

percent_L <- nrow(l) / nrow(results_df)
print(paste("Percent of L telomeres: ", percent_L))

percent_NA <- nrow(results_df[which(is.na(results_df$telomere_end)), ]) / nrow(results_df)
print(paste("Percent of NA telomeres: ", percent_NA))

# Check that new length algorithm works    
L_2k <- ind_2k[L_2k.ind]
candidate_ind <- which(names(telomere_frequencies) == candidates)

## findTelLength needs to be reworked to look for percentages in a
## rolling window, this will allow for some error (missed motifs)
## in the future in may be worth flagging these "low" percentage 
## telomeres for further motif discovery.

# Change naming scheme from L,R to q, p, this needs to be done asap
```

# New Telomere Length Algorithm
```{r new_telomere_length, eval = FALSE}
source(file.path(paths$bin, "f06-Telomere_length.R"))

# Run function
new_results <- parallel::mclapply(telomere_frequencies,
                                  findTelLength, 
                                  st.thresh = 25, 
                                  en.thresh = 10, 
                                  mc.cores = 18)

dim(new_results)
length(new_results)
new_results_df <- do.call(rbind.data.frame, new_results)
head(new_results_df)
ends <- new_results_df$telomere_end
# Count of R and L
table(ends)
```

# Mapping telomere reads to reference
```{r map_telomere_reads, eval = TRUE}



```