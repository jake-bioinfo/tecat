---
title: "TLD Example Vignette"
author: "Jake Reed"
date: '`r Sys.Date()`'
output:
  html_document: 
    theme: simplex
    highlight: tango
    toc: yes
  pdf_document:
    highlight: tango
    toc: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# 1. Installation

# 2. Showcase

## Import Functions
```{r source}
source("00-paths.R")
library(Biostrings)

# Create directories
for (dir in paths) dir.create(file.path(dir), 
                              showWarnings = FALSE)

# Sample name
sample_name <- "HG002_ONT"

# Create results directory
dir.create(file.path(paths$example_results, sample_name), 
           showWarnings = FALSE)

sample_file <- file.path(paths$example_data, 
                         "data/SRR24462105/SRR24462105.fastq")
data_dir <- file.path(paths$example_data, "data", 
                      "SRR24462105")

# Set width
options(width = 300)
```

## Process Fastq
This process is used in order to split files in order to support efficient parallelization. 
Ideally, you would set `target_ram_size_gb` * `threads` to be equal to something near the 
total RAM for your machine. The fastq file can be downloaded from the SRA database using
SRA toolkit. Here are the commands you would use to download the fastq file for this
experiment. 

<!-- ```{bash}
# Download SRA toolkit
wget https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/3.0.7/sratoolkit.3.0.7-ubuntu64.tar.gz
tar -xzf sratoolkit.3.0.7-ubuntu64.tar.gz
cd sratoolkit.3.0.7-ubuntu64/bin
data_dir=r file.path(paths$example_data, "data")
echo $data_dir

# Download fastq file
./prefetch --progress --resume yes --output-directory $data_dir SRR11008518

# Convert to fastq
./fastq-dump --split-3 -A $data_dir/SRR11008518/SRR11008518.sra -outdir $data_dir/split
``` -->

```{r Split_Fastq, eval = FALSE}
source(file.path(paths$bin, "f01-Fastq_Processing.R"))

# Split large fastq file into files that will occupy
# 2GB of RAM in order to take advantage of all processors
# (20) with given RAM (62GB).
if(!file.exists(list.files(file.path(dirname(sample_file), "split"), 
                           full.names = TRUE)[1])) {
   stats_fl <- auto_split(in_fastq = sample_file,
                          prefix = "HG002_ONT", 
                          threads = 18, 
                          extension = ".gz", 
                          target_ram_size_gb = 2)
                          
  # Save stats
  saveRDS(stats_fl, file.path(paths$example_results,
                                sample_name, 
                                "stats_fl.rds"))
}

# Test cmd for ONT
split_fastq(in_fastq = sample_file, 
            size = "50000", 
            prefix = "HG002_ONT", 
            threads = 18, 
            out_dir = paste0(data_dir, "/split"), 
            extension = ".gz")
```

## Process Reference Fastq
```{r process_reference, eval = TRUE}
## Switching denovo motif analysis to streme from meme suite, need 
## to add to dependencies
source(file.path(paths$bin, "f02-Reference_Processing.R"))
options(meme_bin = "~/meme/bin")
reference_file <- file.path(paths$example_data, "ref/chm13v2.0.fa.gz")
reference <- readDNAStringSet(reference_file, format = "fasta")

# Process reference file 
motif_analysis <- telomere_motif(data_ref = reference,
                                 reference_telo_length = 2000,
                                 telo_motif_length = 6, 
                                 number_of_motifs = 10,
                                 number_of_repeats = 9, 
                                 threads = 18)

## Here it appears with new method we can use 6 X motif for ONT, maybe 9 X motif for PB???
## Maybe it doesn't matter. 

# Save results
saveRDS(motif_analysis, file.path(paths$example_results,
        sample_name, "motif_analysis_results.rds"))
```

## Clean up garbage collection
```{r gc}
rm(list=ls()[! ls() %in% c("motif_analysis", "stats_fl", 
                           "reference", "paths", "sample_name", 
                           "data_dir")])
gc()
```

## Isolate telomere reads
```{r telo_search, eval = TRUE}
motif_analysis <- readRDS(file.path(paths$example_results,
                                    sample_name,
                                    "motif_analysis_results.rds"))
# Source functions for pattern searching
source(file.path(paths$bin, "f03-Pattern_searching.R"))

# Run pattern searh on all split fastq files
file_list <- list.files(file.path(data_dir, "split"), 
                        full.names = TRUE)

# Create output directory
out <- file.path(data_dir, "telo")
dir.create(out, showWarnings = FALSE)
# grep_pat <- "TTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGG|CCCTAACCCTAACCCTAACCCTAACCCTAACCCTAA|GGGATTGGGATTGGGATTGGGATTGGGATTGGGATT|AATCCCAATCCCAATCCCAATCCCAATCCCAATCCC|TGAGGGTGAGGGTGAGGGTGAGGGTGAGGGTGAGGG|GGGAGTGGGAGTGGGAGTGGGAGTGGGAGTGGGAGT|ACTCCCACTCCCACTCCCACTCCCACTCCCACTCCC|CCCTCACCCTCACCCTCACCCTCACCCTCACCCTCA"
# Run pattern search on all split fastq files
telomere_stats <- parallel_search(fastq_files = file_list,
                                  grep_pattern = motif_analysis$grep_list,
                                  threads = 18,
                                  out_dir = out,
                                  verbose = TRUE)

# Clean up
rm(list = setdiff(ls(), c("telomere_stats", 
                          "paths", "sample_name")))
gc()

# Save telomere_stats
saveRDS(telomere_stats, file.path(paths$example_results,
                                  sample_name,
                                  "telomere_stats.rds"))
```

## Cut telomere reads into sliding windows
```{r telo_cut, eval = TRUE}
telomere_stats <- readRDS(file.path(paths$example_results,
                                    sample_name,
                                    "telomere_stats.rds"))

# Source functions for cutting telomere reads into sliding windows
source(file.path(paths$bin, "f04-Sliding_window.R"))
dir.create(file.path(paths$example_results, sample_name,
                     "windows"), 
           showWarnings = FALSE)
window_out <- file.path(paths$example_results, sample_name, "windows")

# Test parallel sliding window function
# for loop for multiples of at a time
num_files <- 2
end <- ceiling(length(telomere_stats$file_list) / num_files)
for (i in 1:end) {
  st_ls <- (i-1)*num_files + 1
  en_ls <- i*num_files

  fl_len <- length(telomere_stats$file_list)
  if (en_ls >= fl_len) {
    en_ls <- length(telomere_stats$file_list)
  }

  print(paste0("Processing files ", st_ls, " to ", en_ls))

  telo_windows <- sliding_window_parallel(
    telomere_file_list = telomere_stats$file_list[st_ls:en_ls], 
    window_length = 200,
    threads = 5
  )
  saveRDS(telo_windows, file.path(window_out, 
                                  paste0("telo_windows_", i, ".rds")), 
          compress = FALSE)

  # Status message
  message("\nFinished processing files", st_ls, "to", en_ls, "and\n",
          "saved results file", i, "to", window_out, "\n")

  # Clean up
  rm(telo_windows)
  gc()
}

# Satus
message("\nFinished processing all files and saving results to", window_out, "\n")
```

## Calculate frequency of telomere motifs in sliding windows
```{r telo_freq, eval = TRUE}
# Load in data 
motif_analysis <- readRDS(file.path(paths$example_results, 
                                    sample_name, 
                                    "motif_analysis_results.rds"))

# Source functions for calculating telomere motif frequencies
source(file.path(paths$bin, "f05-Generate_telomere_frequencies.R"))

# motifs <- lapply(motif_analysis$results, function(x) x$motif_seed)
# motifs[[3]] <- "TGAGGG"
# motifs[[4]] <- "CCCTCA"
# motifs[[5]] <- "TTAGGGG"
# motifs[[6]] <- "CCCCTAA"

motifs <- motif_analysis$grep_list

# For loop over all telomere windows files
telo_windows <- list.files(file.path(paths$example_results, 
                           sample_name, "windows"), 
                           pattern = "telo_windows", 
                           full.names = TRUE)

dir.create(file.path(paths$example_results, 
                     sample_name, "frequencies"), 
           showWarnings = FALSE)


file_frequencies <- list()
# For loop processing telo_windows in groups of 5
for (i in 42:length(telo_windows)) {
  t <- readRDS(telo_windows[[i]])
  file_frequencies[[i]] <- telomere_frequencies_lof(
    t, 
    motifs, 
    parallel = TRUE, 
    threads = 3)
  saveRDS(file_frequencies[[i]], file.path(paths$example_results, 
                                           sample_name, "frequencies", 
                                           paste0("file_frequencies_", i, ".rds")), 
          compress = TRUE)
  # Clean up
  rm(t)
  gc()
}

# Save list
saveRDS(file_frequencies, file.path(paths$example_results,
                                    "file_frequencies.rds"))
# File frequencies list
# file_frequencies <- telomere_frequencies_lof(telo_windows, motifs, 
#                                              parallel = TRUE, 
#                                              threads = 3)

# Combined all frequencies into one list
telomere_frequencies <- unlist(lapply(file_frequencies, function(list) {
    unlist(list, recursive = FALSE)}), 
  recursive = FALSE)

# telomere_frequencies <- unlist(file_frequencies, recursive = FALSE)
cat("\nNumber of telomeres found: ", length(telomere_frequencies), "\n")
cat("\nExample telomere frequencies:\n")
knitr::kable(head(telomere_frequencies[[1]]))
cat("\n...")
knitr::kable(tail(telomere_frequencies[[1]]))

# Check 
# freqs_len <- sum(unlist(lapply(file_frequencies, function(x) length(x))))
# all.equal(freqs_len, length(telomere_frequencies))

# Clean up
rm(list = setdiff(ls(), c("telomere_frequencies", 
                          "paths", "sample_name")))
gc()

# Save frequencies
saveRDS(telomere_frequencies, file.path(paths$example_results,
                                        sample_name,
                                        "motif_frequencies.rds"))
```

# Determine telomere length
## !-- Somewhere I need to add telomere name designation in this 
## analysis --!
```{r telomere_length, eval = TRUE}
# Load data
telomere_frequencies <- readRDS(file.path(paths$example_results,
                                          sample_name,
                                          "motif_frequencies.rds"))

# Source functions for determining telomere length
source(file.path(paths$bin, "f06-Telomere_length.R"))

# Threshold determination
thresh_df <- determine_threshold(telomere_list = telomere_frequencies,
                                 threads = 18)

# Save threshold data
saveRDS(thresh_df, file.path(paths$example_results,
                             sample_name, 
                             "threshold_data.rds"))
```

# Explore data
## Inspect threshold data
Need to look into why telomere lengths aren't being calculated for some reads.
```{r inspect_threshold_data}
# Load data
telomere_frequencies <- readRDS(file.path(paths$example_results,
                                          sample_name,
                                          "motif_frequencies.rds"))
thresh_df <- readRDS(file.path(paths$example_results,
                               sample_name,
                               "threshold_data.rds"))

# Number of submitted telomeres
message("Number of submitted telomeres: ", length(telomere_frequencies), 
        "\n")

# Debugging
na_indices <- which(is.na(thresh_df$start[[50]]$telomere_end))
misfits <- telomere_frequencies[na_indices]
# Test all indices are NA
message("Number of NA (misassigned) telomeres: ", length(misfits), 
        "\n")

# Fraction misassigned at best threshold
message("Fraction misassigned at 50-50 threshold: ", 
        length(misfits) / length(telomere_frequencies), "\n")

# Look into first read problem
ref_lens <- thresh_df$start[[50]]
head(ref_lens, 50)

# Look at average length in telomeres
telomere_lengths <- ref_lens$telomere_length[!is.na(ref_lens$telomere_end)]
message("Mean telomere length at 50-50 without NA: ", mean(telomere_lengths), 
        "\n")

# Create histogrma of telomere lengths
hist(telomere_lengths, breaks = sqrt(length(telomere_lengths)), 
     main = "Histogram of Telomere Lengths", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")

# Less than 2k length
ind_2k <- which(telomere_lengths < 2000 & 
                !is.na(telomere_lengths) &
                telomere_lengths > 0)
message("Number of telomeres less than 2kbp: ", length(ind_2k), "\n")
less_2k <- telomere_lengths[ind_2k]
message("Mean of telomere lengths at 50-50 which were less than 2 kbp: ", 
        mean(less_2k), "\n")
hist(less_2k, breaks = sqrt(length(less_2k)), 
     main = "Histogram of Telomere Lengths < 2kbp", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")

minus_2k <- telomere_lengths[which(telomere_lengths > 2000)]
message("Mean of telomere lengths at 50-50 which were greater than 2 kbp: ", 
        mean(minus_2k), "\n")
hist(minus_2k, breaks = sqrt(length(minus_2k)), 
     main = "Histogram of Telomere Lengths > 2kbp", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")
```

## Delve into threshold data, format
This section is going to be focused on constructing a dataset which 
can be looked at more closely. Basically we need a dataset based on 
starting threshold which shows sensitivity while the ending threshold
shows telomere length.
```{r formatting}
# Start sensitivity
start_number_of_telos <- unlist(lapply(thresh_df$start, function(x) {
  length(which(!is.na(x$telomere_end)))}))
sensitivity_df <- data.frame(start = seq(1, 100, 1), 
                             end = rep(5, 100), 
                             number_of_telos = start_number_of_telos)

# Telomere length
# End telomere length
telomere_lengths_end <- lapply(thresh_df$end, function(x) {
  vals <- x$telomere_length[!is.na(x$telomere_end)]
  x <- mean(vals)
  if(x != 0 & length(vals) > 1) {
    std_dev <- sd(vals)
  } else {
    std_dev <- 0
  }
  ret_frame <- data.frame(mean = x,
                          std_dev = std_dev)
  return(ret_frame)
})
end_df <- do.call(rbind, telomere_lengths_end)
telomere_length_df <- cbind(start = rep(20, 100), 
                            end = seq(1, 100, 1), 
                            end_df)

# Print data
message("\nStart sensitivity data:")
knitr::kable(head(sensitivity_df))
message("\n...")
knitr::kable(tail(sensitivity_df))
message("\n")

message("\nTelomere length data:")
knitr::kable(head(telomere_length_df))
message("\n...")
knitr::kable(tail(telomere_length_df))
```

## Plot threshold data
```{r plot_threshold_data}
library(ggplot2)
library(cowplot)

# Plot sensitivity and telomere line graphs next to each other
sens_plot <- ggplot(sensitivity_df, aes(x = start, y = number_of_telos)) +
  geom_line() +
  geom_point() +
  labs(x = "Start Threshold", 
       y = "Number of Telomeres", 
       title = "Telomere Sensitivity") +
  theme_bw()

telomere_plot <- ggplot(telomere_length_df, aes(x = end, y = mean)) +
  geom_line() +
  geom_point() +
  labs(x = "End Threshold", 
       y = "Telomere Length", 
       title = "Telomere Length") +
  theme_bw()

plot_grid(sens_plot, telomere_plot, ncol = 2)

# Print best thresholds
best_start <- sensitivity_df$start[which.max(sensitivity_df$number_of_telos)]
message("\nBest start threshold: ", best_start, "\n")
best_end <- telomere_length_df$end[which.max(telomere_length_df$mean)]
message("\nBest end threshold: ", best_end, "\n")
```

## Determine optimal thresholds
For now run all telomeres with start threshold of
25 and end threshold of 5.
```{r check_lengths}
source(file.path(paths$bin, "f06-Telomere_length.R"))

# Run findtellength over all telomeres in parallel
library(parallel)
# Setup parallel environment
cl <- parallel::makeCluster(18)
parallel::clusterExport(cl, c("findTelLength"), 
                        envir = environment())
invisible(parallel::clusterEvalQ(cl, require(plyr)))

results <- invisible(parallel::parLapply(cl, telomere_frequencies, 
                                         findTelLength, st.thresh = 50, 
                                         en.thresh = 10, 
                                         motif_length = 6))
parallel::stopCluster(cl)

results_df <- do.call(rbind.data.frame, results)

# Save results
saveRDS(results_df, file.path(paths$example_results,
                              sample_name, 
                              "results_df.rds"))

# Look at average length in telomeres
telomere_lengths <- results_df$telomere_length[which(!is.na(results_df$telomere_end) & 
                                               results_df$telomere_length > 0)]
mean(telomere_lengths)

# Create histogrma of telomere lengths
hist(telomere_lengths, breaks = sqrt(length(telomere_lengths)), 
     main = "Histogram of Telomere Lengths", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")
```

```{r less2k}
dim(results_df)
head(results_df)

# Assign NAs 
ind_n_a <- which(is.na(results_df$telomere_end))
n_a <- results_df[ind_n_a, ]  
dim(n_a)
head(n_a)

# Assign < 2k
ind_2k <- which(results_df$telomere_length < 2000 & 
                !is.na(results_df$telomere_end))
less_2k <- results_df[ind_2k, ]
dim(less_2k)
head(less_2k)
```

## Investigate NAs
```{r investigate_nas}
ls()
telomere_frequencies[[ind_n_a[1]]]
message("Correct assignment, this is not a telomere\n")
telomere_frequencies[[ind_n_a[2]]]
message("Correct assignment, this is not a telomere\n")
telomere_frequencies[[ind_n_a[3]]]

# Inspect a random NA
ind <- sample(ind_n_a, 1)
telomere_frequencies[[ind]]
message("Check and see what you find??\n")
message("Wow this is a telomere, but it's not being assigned\n", 
        "\tHG002_036_telomere_17")

# The problem ==> given the low start threshold, the telomere is being
# assigned NA bc both ends are being assigned or above the threshold.
# --> this problem definitely needs to be addressed and corrected, 
# for now rerun with with a threshold of 50 and see what happens.
```

## Investigate < 2k
```{r investigate_2k}
# For loop over all telomere windows files
telo_windows <- list.files(file.path(paths$example_results, 
                           sample_name, "windows"), 
                           pattern = "telo_windows", 
                           full.names = TRUE)
windows <- unlist(readRDS(telo_windows[1]))
length(windows)

# Load up some 2kpb telomeres
ls()
head(ind_2k)
length(ind_2k)
freq_2k <- telomere_frequencies[ind_2k]
res_2k <- results_df[ind_2k, ]
head(res_2k)
names_2k <- rownames(res_2k) 
head(names_2k)

# Check out windows
windows[[1]]
names(windows)
win_2k <- windows[which(names(windows) %in% names_2k)]
head(res_2k)
head(ind_2k)
telomere_frequencies[[ind_2k[1]]]
tail(win_2k[[1]])
message("Correct assignment, this is a short telomere\n")
telomere_frequencies[[ind_2k[2]]]
head(win_2k[[2]])
message("Correct assignment, this is a short telomere\n")
telomere_frequencies[[ind_2k[3]]]
tail(win_2k[[3]], 10)
message("Correct assignment, this is a short telomere\n")
telomere_frequencies[[ind_2k[6]]]
tail(win_2k[[6]], 10)
message("Correct assignment, this is a short telomere\n")

# Change naming scheme from L,R to q, p, this needs to be done asap
```

## What happens if telogator 
```{r telogator}
results_df <- results_df[which(!is.na(results_df$telomere_end)), ]
hist(results_df$telomere_length, breaks = sqrt(length(results_df$telomere_length)), 
     main = "Histogram of Telomere Lengths", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")
message("The mean of telomeres isolated with 80-10 threshold: ", 
        mean(results_df$telomere_length), "\n")
message("The median of telomeres isolated with 80-10 threshold: ", 
        median(results_df$telomere_length), "\n")
message("The standard deviation of telomeres isolated with 80-10 threshold: ", 
        sd(results_df$telomere_length), "\n")

rl_mean <- mean(results_df$read_length)
rl_mean
head(results_df)
```

# Less than 2k length
ind_2k <- which(telomere_lengths < 2000 & 
                is.na(telomere_lengths))
head(ind_2k)
length(ind_2k)
less_2k <- telomere_lengths[ind_2k]
mean(less_2k)
hist(less_2k, breaks = sqrt(length(less_2k)), 
     main = "Histogram of Telomere Lengths < 2kbp", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")

minus_2k <- telomere_lengths[which(telomere_lengths > 2000)]
mean(minus_2k)
hist(minus_2k, breaks = sqrt(length(minus_2k)), 
     main = "Histogram of Telomere Lengths > 2kbp", 
     xlab = "Telomere Length (bp)", 
     ylab = "Frequency")

# Check out telomere_frequencies at index
tail(telomere_frequencies[[ind_2k[1]]], 50)

# Look at first couple of telomeres 
head(results_df)

# Investigate first na telomere
tail(telomere_frequencies[[ind_2k[1]]], 50)
tail(windows[[1]])

# Investigate second na telomere
head(telomere_frequencies[[ind_2k[3]]], 50)
names(windows[[4]])
length(windows[[4]])
windows[[4]][11:37]

# results_df <- results_df[!is.na(results_df$telomere_end), ]
# dim(results_df)
# lengths <- results_df$telomere_length
# hist(lengths, breaks = sqrt(length(lengths)), 
#      main = "Histogram of Telomere Lengths", 
#      xlab = "Telomere Length (bp)", 
#      ylab = "Frequency")
# mean(lengths)

# lengths <- results_df$telomere_length[results_df$telomere_length > 1000]

# # Estimate better bins
# hist(lengths, breaks = sqrt(length(lengths)), 
#      main = "Histogram of Telomere Lengths > 1kbp", 
#      xlab = "Telomere Length (bp)", 
#      ylab = "Frequency")
# mean(lengths)

# # Save results
# saveRDS(results_df, file.path(paths$example_results,
#                               sample_name, 
#                               "telomere_lengths.rds"))
```